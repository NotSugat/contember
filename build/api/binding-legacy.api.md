## API Report File for "@contember/binding-legacy"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Alias } from '@contember/binding-common';
import type { AsyncBatchUpdatesOptions } from '@contember/binding-common';
import { BatchUpdatesOptions } from '@contember/binding-common';
import type { BijectiveIndexedMap } from '@contember/utilities';
import { ContentEntitySelection } from '@contember/client';
import { ContentQuery } from '@contember/client';
import { ContentQueryBuilder } from '@contember/client';
import { DataBindingTransactionResult } from '@contember/binding-common';
import { EntityAccessor } from '@contember/binding-common';
import type { EntityEventListenerStore } from '@contember/binding-common';
import { EntityFieldMarkers } from '@contember/binding-common';
import { EntityId } from '@contember/binding-common';
import { EntityListAccessor } from '@contember/binding-common';
import type { EntityListEventListenerStore } from '@contember/binding-common';
import { EntityListSubTreeMarker } from '@contember/binding-common';
import { EntityName } from '@contember/binding-common';
import { EntityRealmKey } from '@contember/binding-common';
import { EntitySubTreeMarker } from '@contember/binding-common';
import { Environment } from '@contember/binding-common';
import { ErrorAccessor } from '@contember/binding-common';
import type { EventListenersStore } from '@contember/binding-common';
import { ExtendTreeOptions } from '@contember/binding-common';
import { FieldAccessor } from '@contember/binding-common';
import type { FieldEventListenerStore } from '@contember/binding-common';
import type { FieldMarker } from '@contember/binding-common';
import { FieldName } from '@contember/binding-common';
import { FieldValue } from '@contember/binding-common';
import { GraphQlClient } from '@contember/client';
import { GraphQlClientError } from '@contember/client';
import { HasManyRelationMarker } from '@contember/binding-common';
import { HasOneRelationMarker } from '@contember/binding-common';
import { MarkerTreeRoot } from '@contember/binding-common';
import type { PersistErrorOptions } from '@contember/binding-common';
import type { PersistSuccessOptions } from '@contember/binding-common';
import type { PlaceholderName } from '@contember/binding-common';
import { ReceivedDataTree } from '@contember/binding-common';
import { RelativeEntityList } from '@contember/binding-common';
import { RelativeSingleEntity } from '@contember/binding-common';
import { RelativeSingleField } from '@contember/binding-common';
import type { RemovalType } from '@contember/binding-common';
import { RuntimeId } from '@contember/binding-common';
import type { Schema } from '@contember/binding-common';
import { SchemaColumn } from '@contember/binding-common';
import type { ServerId } from '@contember/binding-common';
import { SuccessfulPersistResult } from '@contember/binding-common';
import type { SugaredQualifiedEntityList } from '@contember/binding-common';
import type { SugaredQualifiedSingleEntity } from '@contember/binding-common';
import { SugaredRelativeEntityList } from '@contember/binding-common';
import { SugaredRelativeSingleEntity } from '@contember/binding-common';
import { SugaredRelativeSingleField } from '@contember/binding-common';
import type { SugaredUnconstrainedQualifiedEntityList } from '@contember/binding-common';
import type { SugaredUnconstrainedQualifiedSingleEntity } from '@contember/binding-common';
import { TreeRootAccessor } from '@contember/binding-common';
import type { TreeRootId } from '@contember/binding-common';
import type { UniqueEntityId } from '@contember/binding-common';
import type { UnpersistedEntityDummyId } from '@contember/binding-common';

// @public (undocumented)
export interface BindingConfig {
    // (undocumented)
    beforePersistSettleLimit: number;
    // (undocumented)
    beforeUpdateSettleLimit: number;
    // (undocumented)
    persistSuccessSettleLimit: number;
}

// @public (undocumented)
export class Config {
    constructor(config?: Partial<BindingConfig>);
    // (undocumented)
    getValue<Name extends keyof BindingConfig>(name: Name): BindingConfig[Name];
    // (undocumented)
    setValue<Name extends keyof BindingConfig>(name: Name, value: BindingConfig[Name]): this;
}

// @public (undocumented)
export class DataBinding<Node> {
    constructor(contentApiClient: GraphQlClient, systemApiClient: GraphQlClient, tenantApiClient: GraphQlClient, treeStore: TreeStore, environment: Environment, createMarkerTree: (node: Node, environment: Environment) => MarkerTreeRoot, batchedUpdates: (callback: () => any) => void, onUpdate: (newData: TreeRootAccessor<Node>, binding: DataBinding<Node>) => void, onError: (error: GraphQlClientError, binding: DataBinding<Node>) => void, onPersistSuccess: (result: SuccessfulPersistResult, binding: DataBinding<Node>) => void, options: {
        skipStateUpdateAfterPersist: boolean;
    });
    // (undocumented)
    extendTree(newFragment: Node, options?: ExtendTreeOptions): Promise<TreeRootId | undefined>;
    // (undocumented)
    fetchData(fragment: Node, options?: {
        signal?: AbortSignal;
        environment?: Environment;
    }): Promise<{
        data: ReceivedDataTree;
        markerTreeRoot: MarkerTreeRoot;
    }>;
}

// @public (undocumented)
export class DirtinessTracker {
    // (undocumented)
    getTotalTouchCount(): number;
    // (undocumented)
    hasChanges(): boolean;
    // (undocumented)
    increaseBy(delta: number): void;
    // (undocumented)
    reset(): void;
}

// @public (undocumented)
export class EntityAccessorImpl implements EntityAccessor {
    // Warning: (ae-forgotten-export) The symbol "EntityRealmState" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "EntityOperations" needs to be exported by the entry point index.d.ts
    constructor(state: EntityRealmState, operations: EntityOperations, runtimeId: RuntimeId, key: EntityRealmKey, // ⚠️ This is *NOT* the id! ⚠️
    name: EntityName, fieldData: EntityAccessor.FieldData, dataFromServer: SingleEntityPersistedData | undefined, hasUnpersistedChanges: boolean, errors: ErrorAccessor | undefined, environment: Environment, getAccessor: EntityAccessor.GetEntityAccessor);
    // (undocumented)
    readonly __type: "EntityAccessor";
    // (undocumented)
    addError(error: ErrorAccessor.Error | string): () => void;
    // (undocumented)
    addEventListener<Type extends keyof EntityAccessor.RuntimeEntityEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityAccessor.EntityEventListenerMap[Type]): () => void;
    // (undocumented)
    batchUpdates(performUpdates: EntityAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    connectEntityAtField(field: SugaredRelativeSingleEntity | string, entityToConnect: EntityAccessor): void;
    // (undocumented)
    deleteEntity(): void;
    // (undocumented)
    disconnectEntityAtField(field: SugaredRelativeSingleEntity | string, initializeReplacement?: EntityAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    get existsOnServer(): boolean;
    // (undocumented)
    readonly getAccessor: EntityAccessor.GetEntityAccessor;
    // (undocumented)
    getEntity(entity: SugaredRelativeSingleEntity | string | RelativeSingleEntity): EntityAccessorImpl;
    // (undocumented)
    getEntityList(entityList: SugaredRelativeEntityList | string | RelativeEntityList): EntityListAccessor;
    getField<Value extends FieldValue = FieldValue>(field: SugaredRelativeSingleField | string | RelativeSingleField): FieldAccessor<Value>;
    // (undocumented)
    getMarker(): HasOneRelationMarker | EntitySubTreeMarker | HasManyRelationMarker | EntityListSubTreeMarker;
    // (undocumented)
    getParent(): EntityAccessor | EntityListAccessor | undefined;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    get id(): EntityId;
    // (undocumented)
    get idOnServer(): EntityId | undefined;
    // (undocumented)
    readonly key: EntityRealmKey;
    // (undocumented)
    readonly name: EntityName;
    // (undocumented)
    updateValues(fieldValuePairs: EntityAccessor.FieldValuePairs): void;
}

// @public (undocumented)
export type EntityFieldPersistedData = FieldValue | ServerId | EntityListPersistedData;

// @public (undocumented)
export class EntityListAccessorImpl implements EntityListAccessor {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<EntityAccessor>;
    // Warning: (ae-forgotten-export) The symbol "EntityListState" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ListOperations" needs to be exported by the entry point index.d.ts
    constructor(state: EntityListState, operations: ListOperations, name: EntityName, _children: ReadonlyMap<EntityId, {
        getAccessor: EntityAccessor.GetEntityAccessor;
    }>, _idsPersistedOnServer: ReadonlySet<EntityId>, hasUnpersistedChanges: boolean, errors: ErrorAccessor | undefined, environment: Environment, getAccessor: EntityListAccessor.GetEntityListAccessor);
    // (undocumented)
    readonly __type: "EntityListAccessor";
    // (undocumented)
    addChildEventListener<Type extends keyof EntityAccessor.EntityEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityAccessor.EntityEventListenerMap[Type]): () => void;
    // (undocumented)
    addError(error: ErrorAccessor.Error | string): () => void;
    // (undocumented)
    addEventListener<Type extends keyof EntityListAccessor.RuntimeEntityListEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityListAccessor.EntityListEventListenerMap[Type]): () => void;
    // (undocumented)
    batchUpdates(performUpdates: EntityListAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    connectEntity(entityToConnect: EntityAccessor): void;
    // (undocumented)
    createNewEntity(initialize?: EntityAccessor.BatchUpdatesHandler): RuntimeId;
    // (undocumented)
    deleteAll(): void;
    // (undocumented)
    disconnectAll(): void;
    // (undocumented)
    disconnectEntity(childEntity: EntityAccessor, options?: {
        noPersist?: boolean;
    }): void;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    readonly getAccessor: EntityListAccessor.GetEntityListAccessor;
    // (undocumented)
    getChildEntityById(id: EntityId): EntityAccessor;
    // (undocumented)
    getMarker(): EntityListSubTreeMarker | HasManyRelationMarker;
    // (undocumented)
    getParent(): EntityAccessor | undefined;
    // (undocumented)
    hasEntityId(id: EntityId): boolean;
    // (undocumented)
    hasEntityOnServer(entityOrItsId: EntityAccessor | EntityId): boolean;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    ids(): IterableIterator<EntityId>;
    get idsPersistedOnServer(): Set<EntityId>;
    // (undocumented)
    isEmpty(): boolean;
    keys(): IterableIterator<EntityRealmKey>;
    // (undocumented)
    get length(): number;
    // (undocumented)
    readonly name: EntityName;
}

// @public (undocumented)
export type EntityListPersistedData = Set<EntityId>;

// @public (undocumented)
export class EventManager {
    // Warning: (ae-forgotten-export) The symbol "UpdateMetadata" needs to be exported by the entry point index.d.ts
    constructor(asyncBatchUpdatesOptions: AsyncBatchUpdatesOptions, batchUpdatesOptions: BatchUpdatesOptions, config: Config, dirtinessTracker: DirtinessTracker, onUpdate: (metadata: UpdateMetadata) => void, treeStore: TreeStore, batchedUpdates: (callback: () => any) => void);
    // (undocumented)
    asyncOperation<T>(operation: () => Promise<T>): Promise<T>;
    // (undocumented)
    asyncTransaction<T>(transaction: () => Promise<T>): Promise<T>;
    // (undocumented)
    getEventDispatchers<State extends StateNode, EventListenerTypes extends Exclude<State['eventListeners'], undefined> extends EventListenersStore<infer Map> ? [keyof Map, Map] : never, EventType extends EventListenerTypes[0]>(state: State, event: {
        type: EventType;
        key?: string;
    }, listenerArgs: Parameters<Exclude<EventListenerTypes[1][EventType], undefined>>): Array<() => ReturnType<Exclude<EventListenerTypes[1][EventType], undefined>>> | undefined;
    // (undocumented)
    getEventListeners<State extends StateNode, EventListenerTypes extends Exclude<State['eventListeners'], undefined> extends EventListenersStore<infer Map> ? [keyof Map, Map] : never, EventType extends EventListenerTypes[0]>(state: State, event: {
        type: EventType;
        key?: string;
    }): Set<Exclude<EventListenerTypes[1][EventType], undefined>> | undefined;
    // (undocumented)
    static readonly NO_CHANGES_DIFFERENCE = 0;
    // (undocumented)
    persistOperation(operation: () => Promise<SuccessfulPersistResult>): Promise<SuccessfulPersistResult>;
    // (undocumented)
    registerJustUpdated(justUpdated: StateNode, changesDelta: number): void;
    // Warning: (ae-forgotten-export) The symbol "StateNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    registerNewlyInitialized(newlyInitialized: StateNode): void;
    // (undocumented)
    registerUpdatedConnection(parentState: EntityRealmState, placeholderName: PlaceholderName): void;
    // (undocumented)
    syncOperation<T>(operation: () => T): T;
    // (undocumented)
    syncTransaction<T>(transaction: () => T): T;
    // (undocumented)
    triggerOnBeforePersist(): Promise<void>;
    // (undocumented)
    triggerOnPersistError(options: PersistErrorOptions): Promise<void>;
    // (undocumented)
    triggerOnPersistSuccess(options: PersistSuccessOptions): Promise<void>;
}

// @public (undocumented)
export class FieldAccessorImpl<Value extends FieldValue = FieldValue> implements FieldAccessor {
    // Warning: (ae-forgotten-export) The symbol "FieldState" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "FieldOperations" needs to be exported by the entry point index.d.ts
    constructor(state: FieldState<Value>, operations: FieldOperations, fieldName: FieldName, value: Value | null, valueOnServer: Value | null, defaultValue: Value | undefined, errors: ErrorAccessor | undefined, hasUnpersistedChanges: boolean, touchLog: ReadonlySet<string> | undefined, getAccessor: FieldAccessor.GetFieldAccessor<Value>, schema: SchemaColumn);
    // (undocumented)
    readonly __type: "FieldAccessor";
    // (undocumented)
    addError(error: ErrorAccessor.Error | string): () => void;
    // (undocumented)
    addEventListener<Type extends keyof FieldAccessor.FieldEventListenerMap<Value>>(event: {
        type: Type;
        key?: string;
    }, listener: FieldAccessor.FieldEventListenerMap<Value>[Type]): () => void;
    // Warning: (ae-forgotten-export) The symbol "TemporalFieldHelper" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get asTemporal(): TemporalFieldHelper;
    // Warning: (ae-forgotten-export) The symbol "UuidFieldHelper" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    get asUuid(): UuidFieldHelper;
    // (undocumented)
    clearErrors(): void;
    // (undocumented)
    readonly defaultValue: Value | undefined;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    readonly fieldName: FieldName;
    // (undocumented)
    readonly getAccessor: FieldAccessor.GetFieldAccessor<Value>;
    // (undocumented)
    getParent(): EntityAccessor;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    get isTouched(): boolean;
    // (undocumented)
    isTouchedBy(agent: 'user' | (string & {})): boolean;
    // (undocumented)
    readonly schema: SchemaColumn;
    // (undocumented)
    updateValue(newValue: Value | null, options?: FieldAccessor.UpdateOptions): void;
    // (undocumented)
    readonly value: Value | null;
    // (undocumented)
    readonly valueOnServer: Value | null;
}

// @public (undocumented)
export class NormalizedPersistedData {
    constructor(subTreeDataStore: SubTreeDataStore, persistedEntityDataStore: PersistedEntityDataStore);
    // (undocumented)
    readonly persistedEntityDataStore: PersistedEntityDataStore;
    // (undocumented)
    readonly subTreeDataStore: SubTreeDataStore;
}

// @public (undocumented)
export type PersistedEntityDataStore = Map<UniqueEntityId, SingleEntityPersistedData>;

// @public (undocumented)
export class QueryGenerator {
    constructor(tree: MarkerTreeRoot, qb: ContentQueryBuilder);
    // (undocumented)
    getReadQuery(): Record<string, ContentQuery<any>>;
    // (undocumented)
    static registerQueryPart(fields: EntityFieldMarkers, selection: ContentEntitySelection): ContentEntitySelection;
}

// @public (undocumented)
export type SingleEntityPersistedData = Map<PlaceholderName, EntityFieldPersistedData>;

// @public (undocumented)
export class StateInitializer {
    // Warning: (ae-forgotten-export) The symbol "AccessorErrorManager" needs to be exported by the entry point index.d.ts
    constructor(accessorErrorManager: AccessorErrorManager, batchUpdatesOptions: BatchUpdatesOptions, eventManager: EventManager, treeStore: TreeStore);
    // (undocumented)
    initializeEntityEventListenerStore(blueprint: EntityRealmBlueprint): EntityEventListenerStore | undefined;
    // Warning: (ae-forgotten-export) The symbol "EntityRealmBlueprint" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "EntityRealmStateStub" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initializeEntityRealm(id: RuntimeId, entityName: EntityName, blueprint: EntityRealmBlueprint, copyFrom?: EntityRealmState | EntityRealmStateStub): EntityRealmState | EntityRealmStateStub;
    // Warning: (ae-forgotten-export) The symbol "EntityState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initializeEntityState(id: RuntimeId, entityName: EntityName): EntityState;
    // Warning: (ae-forgotten-export) The symbol "RootStateNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    initializeSubTree(tree: EntitySubTreeMarker | EntityListSubTreeMarker): RootStateNode;
    // (undocumented)
    runImmediateUserInitialization(realm: EntityRealmState | EntityRealmStateStub, initialize: EntityAccessor.BatchUpdatesHandler | undefined): void;
}

// @public (undocumented)
export type SubTreeDataStore = Map<PlaceholderName, ServerId | EntityListPersistedData>;

// @public (undocumented)
export class TreeAugmenter {
    constructor(eventManager: EventManager, stateInitializer: StateInitializer, treeStore: TreeStore, skipStateUpdateAfterPersist?: boolean);
    // (undocumented)
    extendPersistedData(newPersistedData: ReceivedDataTree, markerTree: MarkerTreeRoot): void;
    // (undocumented)
    extendTreeStates(newTreeId: TreeRootId | undefined, newMarkerTree: MarkerTreeRoot): void;
    // (undocumented)
    resetCreatingSubTrees(): void;
    // Warning: (ae-forgotten-export) The symbol "SubMutationOperation" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    updatePersistedData(response: ReceivedDataTree, operations: SubMutationOperation[]): void;
}

// @public (undocumented)
export class TreeStore {
    constructor(_schema: Schema);
    // (undocumented)
    disposeOfEntity(entity: EntityState): void;
    // (undocumented)
    disposeOfRealm(realmToDisposeOf: EntityRealmState | EntityRealmStateStub): void;
    // (undocumented)
    effectivelyHasTreeRoot(candidateRoot: MarkerTreeRoot): boolean;
    // (undocumented)
    readonly entityRealmStore: Map<EntityRealmKey, EntityRealmState | EntityRealmStateStub>;
    // (undocumented)
    readonly entityStore: Map<UniqueEntityId, EntityState>;
    // (undocumented)
    getEntityListPersistedIds(state: EntityListState): ReadonlySet<EntityId>;
    // (undocumented)
    getPathBackToParent(entityRealm: EntityRealmState | EntityRealmStateStub): {
        fieldBackToParent: FieldName;
        parent: EntityRealmState;
    } | undefined;
    // (undocumented)
    getSubTreeState(mode: 'entity', treeRootId: TreeRootId | undefined, aliasOrParameters: Alias | SugaredQualifiedSingleEntity | SugaredUnconstrainedQualifiedSingleEntity, environment: Environment): EntityRealmState;
    // (undocumented)
    getSubTreeState(mode: 'entityList', treeRootId: TreeRootId | undefined, aliasOrParameters: Alias | SugaredQualifiedEntityList | SugaredUnconstrainedQualifiedEntityList, environment: Environment): EntityListState;
    // (undocumented)
    readonly markerTrees: Map<TreeRootId | undefined, MarkerTreeRoot>;
    // (undocumented)
    mergeInMutationResponse(response: ReceivedDataTree, operations: SubMutationOperation[]): void;
    // (undocumented)
    mergeInQueryResponse(response: ReceivedDataTree, markerTree: MarkerTreeRoot): void;
    // (undocumented)
    readonly persistedData: NormalizedPersistedData;
    // (undocumented)
    get persistedEntityData(): PersistedEntityDataStore;
    // (undocumented)
    get schema(): Schema;
    // (undocumented)
    get subTreePersistedData(): SubTreeDataStore;
    // (undocumented)
    readonly subTreeStatesByRoot: Map<TreeRootId | undefined, Map<PlaceholderName, RootStateNode>>;
}


export * from "@contember/binding-common";

// (No @packageDocumentation comment for this package)

```
